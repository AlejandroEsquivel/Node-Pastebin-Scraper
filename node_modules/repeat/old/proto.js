var utils = require("./utils");

var isFunction = utils.isFunction;
var extend = utils.extend;
var chain = utils.chain;
var parseTimeUnitArgs = utils.parseTimeUnitArgs;
var Deferred = require('deferred.js');

var defaultConfig = {
  "task":null,
  "every":-1,
  "times":-1,
  "for":-1,
  "until":null,
  "if":null
};

/**
 *
 * @param arg {Function/Object} Either the function to repeat or a configuration object
 * @return {Repeat} A new instance of Repeat
 * @constructor
 */
function Repeat(arg) {

  if (!(this instanceof Repeat)) {
    return new Repeat(arg);
  }

  arg = isFunction(arg) ? { task:arg } : arg;

  this._config = extend({}, defaultConfig, arg);
  this._state = {
    results:[],
    started:false,
    tickCount:0
  }
}

['every', 'times', 'for', 'if', 'until', 'while'].forEach(function (method) {
  Repeat.prototype[method] = function () {
    this._config[method] = parseTimeUnitArgs.apply({}, arguments);
    return this;
  }
});

Repeat.prototype.cancel = function () {
  if (this._timer) {
    clearTimeout(this._timer);
  }
  this._state.completed = true;
  this.destroy();
};

Repeat.prototype.destroy = function () {
  this._state = [];
  this._config = {};
  console.log(" -> destroyed")
};

Repeat.prototype._tick = function () {
  var result,
      skip = isFunction(this._config.if) && !this._config.if();

  if (this._state.completed) {
    return;
  }

  if (!this._state.started) {
    this._state.started = +(new Date());
  }

  if (isFunction(this._config.until) && this._config.until()) {
    this.cancel();
  } else if (~this._config.for && +(new Date()) - this._state.started > this._config.for) {
    this.cancel();
  } else if (~this._config.times && this._state.tickCount === this._config.times) {
    this.cancel();
  }
  else {
    var next = function (result) {
      this._state.results.push(result);
      if (~this._config.every) {
        this._timer = setTimeout(function () {
          this._tick()
        }.bind(this), this._config.every);
      }
    }.bind(this);

    if (this._config.task.length > 0) { // first argument of function should be the next() callback
      if (!skip) {
        this._config.task(next);
      }
      this._state.tickCount++;
    }
    else {
      if (!skip) {
        result = this._config.task();
      }
      this._state.tickCount++;
      next(result);
    }
  }
  return this;
};

Repeat.prototype.start = function () {

  if (this._state.started) {
    throw new Error("Already started");
  } else if (!this._config.task) {
    throw new Error("Don't know any task to run");
  } else if (!isFunction(this._config.task)) {
    throw new Error("Uh oh, the given task is not a function");
  }

  if (~this._config.every) {
    // we're running in asynchronous mode
    // this timeout is to ensure that first task invocation is carried out asynchronously
    setTimeout(function () {
      this._tick();
    }.bind(this), 0);
  }
  else {  // we're running in synchronous mode
//        if (!~this._config.times && !isFunction(this._config.until)) {
//          // oops, this would cause an infinite loop
//          throw new Error("Cannot run synchronously without knowing how many times. Please specify stop condition, number of times to run, or run asynchronous.");
//        }
    do {
      this._tick();
    } while (!this._state.completed);
  }
};

module.exports = Repeat;