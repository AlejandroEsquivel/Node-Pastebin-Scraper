var utils = require("./utils");

var isFunction = utils.isFunction;
var extend = utils.extend;
var chain = utils.chain;
var withTimeUnit = utils.withTimeUnit;
var Deferred = require('deferred.js');

var defaultConfig = {
  "task":null,
  "every":-1,
  "times":-1,
  "for":-1,
  "until":null,
  "if":null
};

/**
 *
 * @param arg {Function/Object} Either the function to repeat or a configuration object
 * @return {Repeat} A new instance of repeat
 * @constructor
 */
function Repeat(arg) {
  if (!(this instanceof Repeat)) {
    return new Repeat(arg);
  }

  arg = isFunction(arg) ? { task:arg } : arg;

  var self = this,
      config = extend({}, defaultConfig, arg),
      state = {
        results:[],
        started:false
      };
  self.every = chain(withTimeUnit(function (ms) {
    self._config.every = ms;
  }));

  self.times = chain(withTimeUnit(function (ms) {
    self._config.times = ms;
  }));

  self.for = chain(withTimeUnit(function (ms) {
    self._config.for = ms;
  }));

  self.until = chain(function (func) {
    self._config.until = func;
  });

  self.while = chain(function (func) {
    self._config.until = function () {
      return !func()
    };
  });

  self.if = chain(function (func) {
    self._config.if = func;
  });

  self.tick = chain(function () {
    var result,
        next,
        skip = isFunction(self._config.if) && !self._config.if();

    if (self._state.completed) {
      return;
    }

    if (!self._state.started) {
      self._state.started = +(new Date());
    }

    if (isFunction(self._config.until) && self._config.until()) {
      self.cancel();
    } else if (~self._config.for && +(new Date()) - started > self._config.for) {
      self.cancel();
    } else if (~self._config.times && self._tickCount === self._config.times) {
      self.cancel();
    }
    else {
      var _self = self;
      next = function (result) {
        _self._state.results.push(result);
        //(deferred.notify || deferred.progress)(result);
        if (~_self._config.every) {
          _self._timer = setTimeout(function () {
            _self.tick()
          }, _self._config.every);
        }
      };
      if (self._config.task.length > 0) { // first argument of function should be the next() callback
        if (!skip) {
          try {
            self._config.task(next);
          } catch (e) {
            deferred.reject(e);
            throw e;
          }
        }
        self._tickCount++;
      }
      else {
        if (!skip) {
          try {
            result = self._config.task();
          } catch (e) {
            deferred.reject(e);
            throw e;
          }
        }
        self._tickCount++;
        next(result);
      }
    }
  });

  self.start = function () {

    if (self._started) {
      throw new Error("Already started");
    } else if (!self._config.task) {
      throw new Error("Don't know any task to run");
    } else if (!isFunction(self._config.task)) {
      throw new Error("Uh oh, the given task is not a function");
    }

    if (~self._config.every) { // we're running in asynchronous mode
      var _self = self;
      setTimeout(function () { // self timeout is to ensure that first task invocation is carried out asynchronously
        _self.tick();
      }, 0);
    }
    else {  // we're running in synchronous mode
//        if (!~self._config.times && !isFunction(self._config.until)) {
//          // oops, self would cause an infinite loop
//          throw new Error("Cannot run synchronously without knowing how many times. Please specify stop condition, number of times to run, or run asynchronous.");
//        }
      do {
        self.tick();
      } while (!self._state.completed);
    }
    //return deferredLib.promise(deferred);
  };
}


module.exports = Repeat;