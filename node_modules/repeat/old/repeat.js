(function(global) {
  'use strict';
  var
    // --- UTILITY FUNCTIONS
    isFunction = function(obj) {
      return Object.prototype.toString.call(obj) === '[object Function]';
    },

    // Applies a callback to each key-value pair of 
    // a object passing the key and value as parameters 
    eachPair = function(obj, callback) {
      Object.keys(obj).forEach(function(key) { callback(key, obj[key]); });
    },

    // Supported numerals
    numerals = {
      one: 1, two: 2, three: 3, four: 4, five: 5, six: 6, seven: 7, eight: 8,
      nine: 9, ten: 10, twenty: 20, fifty: 50, hundred: 100, thousand: 1000
    },

    // Simple object extend based on underscore.js's _.extend()
    extend = function(obj) {
      Array.prototype.slice.call(arguments, 1).forEach(function(source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      });
      return obj;
    },

    // Supported units and their associated names/abbreviations
    unitsMap = (function () {
      var byName = {};
      [
        {ms: 1, names: ['millis', 'ms', 'milliseconds', 'millisecond']},
        {ms: 1000, names: ['s', 'sec', 'secs', 'seconds', 'second']},
        {ms: 1000 * 60, names: ['m', 'min', 'mins', 'minutes', 'minute']},
        {ms: 1000 * 60 * 60, names: ['h', 'hours', 'hour']}
      ].forEach(function (unit) {
        unit.names.forEach(function (name) {
          byName[name] = unit.ms;
        });
      });
      return byName;
    }()),

    // Creates a proxy around a function and turns it into a function that takes a number and a unit-name as parameters
    // The proxied function will be applied with the converted amount of milliseconds
    // Example:
    //  > var func = withUnitArgs(function(ms) { console.log("Given milliseconds:", ms); });
    //  > func(1, 'minute')
    //  => Given milliseconds: 60000
    //
    // It also ensures given unit is valid:
    //  > func(1, 'lightyear')
    // => Error: Unknown unit "lightyear" must be one of [millis, ms, milliseconds, millisecond, s, (...)]
    //
    // If no unit name is given, milliseconds is assumed
    withUnitArgs = function (func) {
      return function (val, unit) {
        if (unit && !unitsMap[unit]) {
          throw new Error('Unknown unit "' + unit + '" must be one of [' + Object.keys(unitsMap).join(", ") + ']');
        }
        return func.call(func, (unit && unitsMap[unit] * val) || val);
      };
    },
    // Takes a scope object and a function and make sure the function always returns the scope object
    // after its been invoked.
    //
    // Example:
    //  var scope = 1;
    //  var func = chained(scope, function(arg) { console.log(arg); });
    //  func('foo') == scope
    //  => true
    chained = function (instance, func) {
      return function () {
        func.apply(func, arguments);
        return instance;
      };
    }
    function Repeat() {

    }
    var use = function(name) {
      if (arguments.length === 2) { // it was called with the adapter as second parameter, register it first
        support(name, arguments[1]);
        return use(name);
      }
      var lib = supportedLibs[name.toLowerCase()];
      if (typeof lib === 'undefined') {
         throw new Error("Support for '"+name+"' not found. Add it with Repeat.support('"+name+"', [adapter])");
      }

      function Repeat(task) {
        var
          params,
          timer,
          tick,
          results = [],
          tickCount = 0,
          started = false,
          completed = false,
          deferredLib = lib,
          deferred = deferredLib.defer(),
          self = extend({}, deferredLib.promise(deferred));

        params = {
          task: task || null,
          every: -1,
          times: -1,
          for_: -1,
          until: null,
          if_: null
        };
    
        self.task = chained(self, function (task) {
          params.task = task;
        });
    
        self.every = chained(self, withUnitArgs(function (ms) {
          params.every = ms;
        }));
    
        self['for'] = self.lasting = chained(self, withUnitArgs(function (ms) {
          params.for_ = ms;
        }));
    
        self['if'] = self.provided = chained(self, function (func) {
          params.if_ = func;
        });
    
        self.unless = chained(self, function (func) {
          params.if_ = function () { return !func(); };
        });
    
        self['while'] = self.during = chained(self, function (func) {
          params.until = function () { return !func(); };
        });
    
        self.times = chained(self, function (times) {
          params.times = times;
        });
    
        self.until = chained(self, function (func) {
          params.until = func;
        });

        self.start = function() {
    
          if (started) {
            throw new Error("Already started");
          } else if (!params.task) {
            throw new Error("Don't know any task to run");
          } else if (!isFunction(params.task)) {
            throw new Error("Uh oh, the given task is not a function");
          }
    
          if (~params.every) { // we're running in asynchronous mode
            setTimeout(function() { // this timeout is to ensure that first task invocation is carried out asynchronously
              tick();
            }, 0);
          }
          else {  // we're running in synchronous mode
    //        if (!~params.times && !isFunction(params.until)) {
    //          // oops, this would cause an infinite loop
    //          throw new Error("Cannot run synchronously without knowing how many times. Please specify stop condition, number of times to run, or run asynchronous.");
    //        }
            do { tick(); } while (!completed);
          }
          return deferredLib.promise(deferred);
        };
    
        self.start['in'] = self['in'] = self.wait = withUnitArgs(function (ms) {
          timer = setTimeout(function () {
            self.start();
          }, ms);
          return deferredLib.promise(deferred);
        });
    
        self.next = chained(self, function() {
          tick();
        });
    
        self.stop = chained(self, function () {
          if (!started) { self.cancel(); }
          params.times = tickCount+1; // do not cancel if between two invocations
        });
    
        self.cancel = chained(self, function () {
          if (timer) { clearTimeout(timer); } 
          deferred.resolve(results);
          completed = true;
        });
    
        self.async = chained(self, function() {
          return self.every(0, 'ms');
        });
    
        // Expose predefined numerals as api functions
        eachPair(numerals, function (key, value) {
          self[key] = {times: function () {
            self.times(value);
            return self;
          }};
        });
    
        // Add some grammatical convenience
        self.once = self.one.time = self.one.times;
        self.twice = self.two.times;
        self.now = self.start.now = self.start;
     
        return self;
      }
      return Repeat;
    };

  // Finally, export it as CommonJS module *or* to to the global object as Repeat
  if (typeof exports !== 'undefined') {
    module.exports = Repeat; // CommonJS
  }
  else {
    // Export Repeat to global object
    global.Repeat = Repeat;    
  }

}(this));