var utils = require("./utils");

var isFunction = utils.isFunction;
var extend = utils.extend;
var chain = utils.chain;
var Deferred = require('quickdefer');

function Repeat(task) {
  if (!this instanceof Repeat) {
    return new Repeat();
  }
  var
      params,
      timer,
      tick,
      tickCount = -1,
      results = [],
      completed = false,
      self = extend({}, deferredLib.promise(deferred));

  params = {
    task:task || null,
    every:-1,
    times:-1,
    for_:-1,
    until:null,
    if_:null
  };

  self.task = chain(self, function (task) {
    params.task = task;
  });

  self.every = chain(self, withUnitArgs(function (ms) {
    params.every = ms;
  }));

  self['for'] = self.lasting = chain(self, withUnitArgs(function (ms) {
    params.for_ = ms;
  }));

  self['if'] = self.provided = chain(self, function (func) {
    params.if_ = func;
  });

  self.unless = chain(self, function (func) {
    params.if_ = function () {
      return !func();
    };
  });

  self['while'] = self.during = chain(self, function (func) {
    params.until = function () {
      return !func();
    };
  });

  self.times = chain(self, function (times) {
    params.times = times;
  });

  self.until = chain(self, function (func) {
    params.until = func;
  });


  tick = chain(self, function () {
    var result,
        done = function (result) {
          results.push(result);
          (deferred.notify || deferred.progress)(result);
          if (~params.every) {
            timer = setTimeout(tick, params.every);
          }
        },
        skip = isFunction(params.if_) && !params.if_();

    if (completed) {
      return;
    }

    if (!started) {
      started = +(new Date());
    }

    if (isFunction(params.until) && params.until()) {
      self.cancel();
    } else if (~params.for_ && +(new Date()) - started > params.for_) {
      self.cancel();
    } else if (~params.times && tickCount === params.times) {
      self.cancel();
    }
    else {
      if (params.task.length > 0) { // first argument of function should be the done() callback
        if (!skip) {
          try {
            params.task(done);
          } catch (e) {
            deferred.reject(e);
            throw e;
          }
        }
        tickCount++;
      }
      else {
        if (!skip) {
          try {
            result = params.task();
          } catch (e) {
            deferred.reject(e);
            throw e;
          }
        }
        tickCount++;
        done(result);
      }
    }
  });

  self.start = function () {

    if (started) {
      throw new Error("Already started");
    } else if (!params.task) {
      throw new Error("Don't know any task to run");
    } else if (!isFunction(params.task)) {
      throw new Error("Uh oh, the given task is not a function");
    }

    if (~params.every) { // we're running in asynchronous mode
      setTimeout(function () { // this timeout is to ensure that first task invocation is carried out asynchronously
        tick();
      }, 0);
    }
    else {  // we're running in synchronous mode
      //        if (!~params.times && !isFunction(params.until)) {
      //          // oops, this would cause an infinite loop
      //          throw new Error("Cannot run synchronously without knowing how many times. Please specify stop condition, number of times to run, or run asynchronous.");
      //        }
      do {
        tick();
      } while (!completed);
    }
    return deferredLib.promise(deferred);
  };

  self.start['in'] = self['in'] = self.wait = withUnitArgs(function (ms) {
    timer = setTimeout(function () {
      self.start();
    }, ms);
    return deferredLib.promise(deferred);
  });

  self.next = chain(self, function () {
    tick();
  });

  self.stop = chain(self, function () {
    if (!started) {
      self.cancel();
    }
    params.times = tickCount + 1; // do not cancel if between two invocations
  });

  self.cancel = chain(self, function () {
    if (timer) {
      clearTimeout(timer);
    }
    deferred.resolve(results);
    completed = true;
  });

  self.async = chain(self, function () {
    return self.every(0, 'ms');
  });

  // Expose predefined numerals as api functions
  eachPair(numerals, function (key, value) {
    self[key] = {times:function () {
      self.times(value);
      return self;
    }};
  });

  // Add some grammatical convenience
  self.once = self.one.time = self.one.times;
  self.twice = self.two.times;
  self.now = self.start.now = self.start;

  return self;
}